# Cities and code workshop
# Cities in code: how software repositories express urban life

Adrian Mackenzie

Is code an expression of urban life? This paper analyses around 10 million software repositories on GitHub.com from the perspective of how they include cities.  The methodology here relies on data-intensive work with bodies of code at a number of different levels. It maps the geographies of GitHub organisations and users to see how location anchors coding work.  More experimentally, it tracks how urban spaces, movements and architectures figure in and configure code. The paper's focus is less on how code shapes cities and more on apprehending code and coding as a way of experientially inhabiting cities. This approach might better highlight how code expresses urban experiences of proximity, mixing, movement, nearness, distance, and location. It might also shed light on the plural forms of spatiality arising from code, particularly as algorithmic processes become more entangled with each other. 

# Ideas

- note code captures city, or data captures city, but code as data: what kind of data does code give on the city?
- what abstracts cities into other infrastructures?- what reorganizes practices via devices?
- what reorganizes aesthesis?
- examples: node.js -- its concurrency architecture; hadoop -- its failure model and its layers; bootstrap/angular -- its redoing of the web;
- implications of seeing the city in code: against the story of the power of the algorithm or the power of the machine;

## Quotes
forces are dependent upon and operationalized through all manner of forms of quantitative calculation, from the very simplest operations like listing and numbering and counting through to various kinds of analytical and transformative operations. Thrift 2004 583

Take just the case of coded cities understood as a whole. Should we think of them simply as projections of an autistic capitalist power in which all consequences are externalized? Should we think of them as entities gathered around matters of prescribed concern and uninterested in much that lies outside them? Should we see them as tied into a kind of ethic of care by the need to roll over systems which demand resilience? Should we see them as having an increasingly involved dream life, based on projection and retrojection of all the searches, blogs and tweets that are continually being generated? Should we see them as geometric beings, born out of constant requests for navigation? Should we see them as the result of newly found abilities to represent arising out of advances in visualization? There is no set format or single cause but what is clear is that it is increasingly possible for these entities to learn – in however a limited way – to transform themselves, to author themselves either through emergent tendencies arising out of complexity or through simple happenstance which places them in unexpected situations which require adaptation. Thrift, 2014, 13

It would be easy at this point to fall back on some familiar notions to describe software’s grip on spaces like cities. One would be hegemony. But that notion suggests a purposeful project, whilst software consists of numerous projects cycling through and continually being rewritten in code. Another notion would be haunting. But again the notion is not quite the right one. Ghosts are ethereal presences, phantoms that are only half- there, which usually obtain their effects by stirring up emotions – of fear, angst, regret, and the like. Software is more like a kind of traffic between beings, wherein one sees, so to speak, the effects of the relationship. What transpires becomes reified in actions, body stances, general anticipations (Strathern 1999). We would argue, then, that soft- ware is best thought of as a kind of absorption, an expectation of what will turn up in the everyday world. Software is a new kind of phenomenality which can ‘touch the ontic’ (Spivak 1993, 30). Software is, in other words, a part of a ‘technologi- cal unconscious’ (Clough 2000), a means of sustain- ing presence which we cannot access but which clearly has effects, a technical substrate of uncon- scious meaning and activity. Thrift-French, 2002, 311-312

Is there any way of making a more general assessment of software in the city? 2002,  314

The initial step can be made through the venerable geographical act of mapping the expanding realm of machinekind, clearly part of the remaining terra incognita. Horvath, 1974, 188

## Introduction
> We would argue, then, that soft- ware is best thought of as a kind of absorption, an expectation of what will turn up in the everyday world [@Thrift_2002, 311]

## Software geographies 2002 - 2014: centres, rules and emergences

Writing in 2002, Nigel Thrift and Shaun French asked: 'is there any way of making a more general assessment of software in the city?' [@Thift_2002,  314]. Their practical response to that question took the shape of the Y2K bug, and the lists of software potentially affected by it: keypad locks, pagers, solar panels, smoke detectors, camcorders, VCRs, elevators. Although these lists look somewhat old-fashioned in 2014, when a similar listing would include so many  things that didn't exist in 2002, Thrift and French's description of the trends in software development and urban space  still largely applies: 'we will exist in a broadband world in which the internet will be a permanently available ‘cloud’ of information able to be called up through a number of appliances scattered through the environment. These appliances will be something more than portals for information. Rather, like many other devices which will not have internet connections, they will be "practice-aware"' (315) and 'will, through a process of cultural absorption into practices, sink down from the representational into the non- representational world, so becoming a part of a taken-for-granted set of passions and skills' (318). Again, the fact that these developments more than a decade later are still very much in train suggests that there is something quite predictable about the development of software and coding in organising urban life and spaces.  

What of the more general assessment of software in the city general analysis that Thrift and French propose? In 2002 they suggested that three geographies were driving code into cities. First, the geography of coding needed to be considered: 

	>  The first of these geographies is the most obvious, the large and complex geography of the writing of software – of the production of lines of code – a geography that takes in many different locations and many different languages and which has been built up progressively since the invention of programming in the 1940s.  [@Thrift_2002, 323]

According to Thrift and French, the geography of software production is concentrated into a very few key places and regions: Silicon Valley, New York, London, and a number of subsidiary and sometimes mass production software locations (often concentrating on tasks like consulting, testing and support) in countries like Ireland and India. China, Russia and Brazil are not mentioned, but otherwise things remain more or less the same there.   Second, a geography of power, which they conceived in Foucaultean terms as the conduct of conduct, or massive proliferation of corporeally practiced rules, operates through software: 'in essence, we can say that it consists of rules of conduct able to be applied to determinate situations' [@Thrift_2002, 325]. Through power geography, software becomes increasingly interlinked rather than discrete processes. Again, with the growth of data analytics, virtualizing computing infrastructures, social media, mobile apps and sensors is largely consistent with this analysis of power. The final geography is the most open, and in a sense it is the least geographically localised: 'the general profusion of software, its increasing complexity and consequent emergent properties, all count as means of producing playful idioms that have not been captured by dominant orders. Software’s very indeterminacy and lack of closure provide a means of creating new kinds of order' (328). These playful idioms are largely irreducible to the centres of coding and the determinate situations and therefore will take on singular forms, unexpected locations and non-representational aspects. Again, it would not be too hard to see this process still in play today. The huge appstores, the many art-related coding projects, electronic music, etc all provide ample cases of the ways in which people product heterogeneous software idioms that provisionally destabilise geographies of power. 

Although you might just as well read the article yourself, one final contribution is worth revisiting. Against the contemporary attempts to see software and code as either hegemonic, as an epochal shift, as what has always haunted writing, or as the epitome of the post-human technics, they sketched  a conception of the phenomenality of code  that still remains executable today: 

	> Software is more like a kind of traffic between beings, wherein one sees, so to speak, the effects of the relationship. What transpires becomes reified in actions, body stances, general anticipations (Strathern 1999). We would argue, then, that software is best thought of as a kind of absorption, an expectation of what will turn up in the everyday world.[@Thrift_2002, 312]

These formulations are the loosest and most adumbratory in the paper.  But the 'traffic between beings' they refer to here, the reification of 'general anticipations,' the curiously contrasting descriptions of software as absorption _and_ expectation seem worth working to both understand what has continued to run along the lines that Thrift and French describe, and what has been added on, what has diverged or forked in the runtime since 2001. 

In 2014, how can we think about software  in ways that apprehends both its power-laden capacity to format lives, experience, space and time, and at the same time, sees software as itself a multiplicity, with its own becomings, differences, and changes, as the new kind of phenomenality Thrift and French describe? I propose one theoretical move and one practical way of experimenting with large aggregates of code in movement. The theoretical move is to position code and software as 'a kind of traffic between beings' rather than seeing code and software as shaping the city. This is not to say that code does not still act on cities, on space, on public and private practices.  High profile and much discussed changes taking place in computational platforms (mobile devices, cloud, etc) and in algorithmic processes (machine learning) intricately reorganise urban life. What transpires there is rapidly reified in actions, body stances, etc.   But it might also be worth seeing how cities, with their massive centralising tendencies, with their sometime globe-spanning relationalities, with their density of infrastructures, with their high rates of reconstruction and repair, and with their affective-practical-epidemiological crowd contagions _crowd_ into  contemporary software. We would, from this standpoint, no longer concentrate on following how software, code and algorithms emanate from global centres  as hypervisory control structures  reorganizing cities.  Instead, we would apprehend code itself as something closer to streets, to traffic and to crowds. That is to say, software and code have become noisy, crowded, propagating aggregates. 

The practical suggestion that follows from seeing code as crowd concerns what we should see as the objects of research in studying software and code. If code is a kind of traffic between beings, if is not only a community but a metacommunity, not only an ecology but a crowd then we need to find ways that studying it as a shape-shifting crowd form.  I'm not going to discuss this in any great detail here as this would require a lengthy methological digression. In what follows, however, various elements of a different kind of sensibility to software-code as relational traffic as a source-crowd are in play, and they draw on various code and data infrastructures ranging from the APIs, cloud analytics platforms such as Google BigQuery, newer forms of database and interactive data analysis environments such as ipython and R. 

## From crowd-sourcing to source-code crowding: code repository traffic
## The centrality of GitHub as repository

It is not hard to see this general shift when we look at recent transformations in  work on code and how code circulates. Coding work itself has become a media practice in the sense that huge number of code repositories (possibly around 50 million)  are now publically online at code repository sites such as GitHub.com, Bitbucket.com, code.google.com and SourceForge.com.  The geographies of production have shifted greatly. The modes of participation and openness of coding have multiplied polysemically. The split between the centralised geographies of software production and the geographies of emergence is less visible than it was in the more static and segmented platforms of the 1990s. 

Focusing even on one of these repositories -- GitHub.com, allegedly the 'largest code repository on planet' -- might be a way to begin to find a way of beginning to see crowds, streets, and urban life in code. (It might also be a way of doing some demolition work on the growing edifice of algorithmic ontology, an edifice that is blocking light, I would suggest, on the richer cultural and social life of code forms.) The name 'GitHub' is not very promising. 'git,' an English word for a male person who acts foolishly or annoyingly, was chosen by Linus Torvalds in 2005 as the name for a new concurrent versioning system for source code, the written texts on which nearly all software development pivots. In 2002, Torvald's work on  GNU/Linux still epitomised for many people the emergent power of open source collaboration on the internet to build things outside the geographies of the software industry.  (But even then, as Thrift and French observed,  Linux was a quite centralised hierarchically and industry-supported software project). `git` is a piece of software,   a revision control system for code that allows incremental changes made by many people working a common project to either coexist or merge. Git is currently probably the most widely used revision control system for code. It was meant to be radically de-centralised in that no particular instance of a git repository would be the 'master.' 'Local' and 'remote' repositories matter to `git` but their differences are only relative. Your local git repository is my remote. And my local git repository is your remote. Instead, a decentralized network of repositories would push and pull code to each other. Different repositories would clone and branch off from each other, and occasionally would merge again, but not necessarily.  

All of this is somewhat familiar 2000s network-style cooperative work. What do the large code repository platforms like  GitHub add?  Since late 2007, GitHub has provided  a shared platform for many git repositories.  From the perspective of  the `git` software, GitHub is just another remote  code repository. But given that many, in fact around 13 million, local `git` repositories have GitHub.com as their remote repository, then GitHub becomes a hub for `git.` Like `git`, GitHub.com as a platform, and indeed as  a social media platform for coding, proclaims a radically de-centered structure. Several hundred GitHub staff are scattered across a  dozen or so countries, a somewhat disperse geography for a relatively specialised software company started in 2007 in San Francisco. GitHub work life is also putatively non-hierarchical, with no management hierarchy, only a `git`-like structure of fluid teams working on projects.  The only problem with this is that the CEO and  GitHub co-founder, Tom Preston-Werner (a.k.a `mojombo`, id = '1' -- in other words, the first Githubber ever) has recently had to step down after much publicised allegations of sexist and discriminatory language and behaviour. His git-like features aside, GitHub as a social media platform adds many layers of social media-style interface to code repositories, entities which by tradition, have been rather austere almost Reformation-style architectures. That is, they adorn code repositories with all the social media-style apparatus of following, watching, liking, and tagging. So the social life of code repositories is formatted much more in terms of watchers and followers in the same way that messages  on Twitter or pages on Facebook are watched and followed. 


## Github as a recursive crowd: geography, events and repositories

If we look at the 233 staff listed as the Github team, there is some evidence of their socially networked existence as they work to socially network code. Githubbers such as `defunkt`, `mojombo`  or `technoweenie` have thousands of followers and hundreds of repos. Some of their repositories are heavily forked, suggesting that 'passionate imitation' occurs around their code.  Precisely what is being followed here requires more detailed investigation, but these several hundred team members all use Github itself to do their work on building Github. So the hub-ness or centrality of Github for this team is something to be produced or made via a combination of geography, rules of conduct and new forms of order. As a repository of repositories, Github's mode of existence as code is a recursively generated movement propelled in part by the Githubber's network of repositories and their interconnections with other repositories. 

The geography of their work on Github is still centralised, despite claims of de-centralization:

!['Github Team geography by country and city']('plots/github_team_repos_by_event_count.png')

We can see some f what the Github team has been doing in Github repositories by running queries against the Github API or using the GithubArchive.org archived datastream of Github activity. For those who read SQL, the query is something like:

> SELECT actor, repository_url, type, count(type) as event_count FROM [githubarchive:github.timeline] where  actor = '{}' group each by actor, repository_url, type order by event_count desc LIMIT 1000

This says find all the public repositories on which the named 'actor' works, and count the different actions they perform on those repositories. If we run this query for all 233 Githubbers as well as `mojombo`, then something of the network of work done on 
Github itself begins to appear. The table below offers some way of looking at what happens in the Github team as they work on Github as a  platform. (Just to note: only some of the things they work on appear here. The Github team has private repositories and in particular, the most recursive repository of all, `github/github` is private.)

type	count
------  ---------
PushEvent                        112028
IssueCommentEvent                 84098
PullRequestEvent                  35990
CreateEvent                       31080
IssuesEvent                       25953
PullRequestReviewCommentEvent     16390
WatchEvent                        13627
DeleteEvent                        8033
FollowEvent                        5400
ForkEvent                          5283
CommitCommentEvent                 4542
GistEvent                          3063
GollumEvent                        2260
ReleaseEvent                        910
MemberEvent                         897
PublicEvent                         569
DownloadEvent                       350
ForkApplyEvent                        6
-------------------------------------
Table: Events generated by Github Team since early 2012

![Figure: Events on Github Team public repositories]('/plots/events_github_team.png')

The Github team works on around 17000 public repositories in total, but they work much more heavily on several hundred of these.

!['The main repositories the Github team works on'](plots/github_team_repos_by_event_count.svg')

## The most important repositories on Github for Github

The top repositories here are worth describing as they present some of the pieces of Github as a platform, although the main platform itself, as mentioned above. This major exception aside, there are quite a few that clearly relate to Github or `git` itself. It is hardly surprising that Githubbers contribute to the `git` repository or implementations of `git` such as `libgit2`, `objective-git`, `rugged`, or `hub`, a 'wrapper' for `git`. (It would be perhaps interesting to what kind of contributions they make.) They also make contributions to repositories that relate to Github, ranging from document websites such as https://developer.github.com or http://teach.github.com, websites that promote or showcase Github (https://government.github.com/) or its features (24pullrequests), repositories for testing Github (hellogitworld), repositories that acts as Q&A sites about Github(feedback), repositories that contain code for accessing the Github APIs (http://octokit.net) or link Github with other webservices (github-services) or code development systems (git-tfs). 

As well, the Github team has worked heavily on tools and configurations for editing code. Repositories such as cloud9, dotfiles,  gitignore, vimmode, rbenv, ace, and atom figure heavily, and this is also not surprising as the work of coding involves a lot of editing and drawing on existing code. Getting editing tools and software development environments setup is a major preoccupation with software developers. The most worked on repository, homebrew, is  just such a configuration repository -- it implements a software package management systems for MacOS computers 

There are also quite a few repositories that concern the Github workplace itself. `Play` is a music server: 'We have employees all over the world, but Play lets us all listen to the same music as if we were all in the office together. This has actually made a big impact on our culture.' (https://github.com/github/play). Similarly, `Hubot` and `Hubot-scripts` are part of  a chatbot system  that the Github team extensively use to maintain and run the many online chatrooms they use as they work with each other. They run one Hubot for the whole of Github. Or collaborative document revision systems for spreadsheets (`WP-document-revisions`).

Finally, many repositories listed here concern the infrastructure of Github.com as a social media platform. Some are language specific environments heavily used at Github such as `rubinius`, an implementation of the Ruby programming language. Some such as `rails` are web-framework  libraries and they provide much of the dynamic infrastructure on Github. Other repositories such as `choose-a-licence` or `linguist` implement Github features to do with licensing or tagging repositories by programming language.  Since Github repositories can also function as webpages, blogs, or wikis, other repositories such as `jekyll` and `gollum` provide code for that. Other heavily used repositories such as `bootstrap`, `zepto` and `twui` provide elements of the graphic layout, colours, styles, fonts and icons that comprise the visual appearance and interactive features of Github pages. 

## On watching, starring, forking, pull-requesting -- the dynamics of code flow


-- very different situation to FLOSS, etc in many ways - cf some of the literature on OSS; somewhat indifferent to IP, in ways that crowds are indifferent to property
-- the preliminary metrics of imitation -- forking,
-- the preliminary metrics of 2nd  imitation -- names
-- 







In terms of social life,  software today is less like a machine, a system or even an assemblage, and more like a crowd. That is, it has fluxing, flowing and somewhat disordered existence that generates powerful flashes and movements, that creates atmospherics and densely woven patches of order, but remain unstable and dynamic. 

